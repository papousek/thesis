\chapter{Implementace}\label{chapter:implementation}
Následující kapitola se věnuje aplikaci Parasim, jejíž jsem hlavním spoluautorem.
Tato aplikace implementuje algoritmus pro
analýzu dynamických systémů zmíněný v sekci \ref{section:algorithm:updated}. Aplikace Parasim
vznikla na základě prototypu dostupného v \cite{drazan2011}. Cílem prototypu je názorně
zobrazit průběh výpočtu původního algoritmu. Uživateli se ukazuje, jakým způsobem
se počítá vzdá\-le\-nost mezi trajektoriemi chování, kde je nutné zahušťovat a jak dopadlo
ověření platnosti. Vzhledem k tomu, že prototyp například používá pouze jednoduchou metodu
numerické simulace k nalezení trajektorií chování, není vhodné jej použít k analýze složitějších modelů.

V nové implementaci bylo oproti prototypu třeba zahrnout následující:

\begin{enumerate}
	\item	úprava algoritmu dle sekce \ref{section:algorithm:updated},
	\item	paralelní výpočet ve sdílené nebo distribuované paměti,
	\item	rozšiřitelnost, modularita a otevřenost k rozdílné implementaci již naimplementovaných částí,\label{item:features:extensibility}
	\item	zobrazení výsledků analýzy pro vícedimenzionální prostory ini\-ciál\-ních podmínek.\label{item:features:visualisation}
\end{enumerate}

Tato práce se zabývá všemi zmíněnými body kromě bodu \ref{item:features:visualisation},
který je však v Parasimu již také vyřešen. Vzhledem k monolitické implementaci prototypu
nedošlo k jeho úpravám a rozšíření, ale vytvořila se od základu nová aplikace.
Bod \ref{item:features:extensibility} je důležitý z několika důvodů. Pro různé části algoritmu
existuje více způsobů, jak je naimplementovat. Existuje například mnoho nástrojů umožňujících
numerickou simulací na základě systému diferenciálních rovnic získat trajektorii chování.
V případě výpočtu robustnosti se nemusíme omezit pouze na temporální logiku signálů,
ale můžeme zavést logiku novou, expresivněj\-ší.

Kapitola je členěna do tří hlavních částí. První z nich se věnuje architektuře aplikace,
zejména jejímu jádru, které zajišťuje modularitu a základní služby nezbytné pro načítání
a správu dalších rozšíření. Další sekce popisuje výpočetní model,
jenž byl vytvořen za účelem sjednocení implementace výpočtu ve sdílené a distribuované paměti.
V závěru kapitoly se na\-chá\-zí stručný popis rozšíření použitých v algoritmu pro analýzu
dynamických systémů.

\section{Architektura}

Parasim je aplikace napsaná v Javě 7 složená z většího množství artefaktů pro
sestavovací nástroj Maven. Zdrojové kódy jsou pod licencí GNU GPL verze 3~\cite{gpl} k dispozici
v Git \cite{chacon2009} repozitáři \url{https://github.com/sybila/parasim}. Artefakty sestavené
z poslední verze těchto zdrojových jsou publikovány do Maven repozitáře
\url{http://repository-sybila.forge.cloudbees.com/snapshot/}, o což se stará veřejná
instance nástroje Jenkins \cite{jenkins} \url{http://www.cloudbees.com/}. Artefakty
vydaných verzí jsou k nalezení v Maven repozitáři \url{http://repository-sybila.forge.cloudbees.com/release}.
Hlavní aplikaci Parasimu představuje artefakt \texttt{org.sybila.parasim.application:parasim}.
Pou\-ži\-tí aplikace je popsáno v příloze \ref{appendix:usage}

Jádro Parasimu tvoří artefakt \texttt{org.sybila.parasim:core}, který řídí ži\-vot\-ní
cyklus všech modulů a zajišťuje základní funkcionalitu. To zajišťuje kontejner,
jehož instance je vytvořena a spuštěna v rámci aplikace. Kontejner je velkou mírou inspi\-ro\-ván
konceptem \textit{Context and Dependency Injection} zavedeným v~Java~EE~6~\cite{jendrock2010} specifikací
JSR-299 \cite{jsr299}. V žádném případě se nejedná o~implementaci tohoto standardu,
nýbrž jen o volnou inspiraci některými koncepty, které umožňují úplné oddělení rozhraní
od implementace, lepší testovatelnost a práci s pamětí.

Nejdůležitějším aspektem je použití kontextů, které mají různou délku a je možné je za\-no\-řo\-vat.
Rozšíření pro jednotlivé kontexty nabízejí služby a~aplikace definuje na různých
místech v~kódu závislosti na těchto službách. Kontejner se stará o to,
aby v případě požadavku na nějakou službu bylo zavoláno příslušné rozšíření,
které ji poskytuje. Rozšíření vytvoří instanci služby a v případě vy\-pr\-še\-ní kontextu
tuto instanci vhodným způsobem zničí.

Za vytvoření a zničení instance služby je tak zodpovědný autor rozšíření,
který také definuje příslušná rozhraní. Aplikace není téměř žádným způ\-so\-bem závislá
na implementaci rozhraní, a jednotlivé implementace lze tak jednoduše zaměňovat,
aniž bychom v~aplikačním kódu cokoliv mě\-ni\-li.

\subsection{Životní cyklus}

Aby bylo možné jádro Parasimu používat, je nutné nastartovat jeho životní cyklus pomocí třídy
\href{https://github.com/sybila/parasim/blob/2.0.0.Final/core/src/main/java/org/sybila/parasim/core/impl/ManagerImpl.java}{\texttt{ManagerImpl}}.
Tato třída představuje vstupní bod pro použití veškeré dále popsané funkcionality
včetně jednotného přístupu ke konfiguraci nebo injektování instancí služeb do atributů daných objektů.
Životní cyklus řízený vytvořením, nastartováním a destrukcí tohoto ma\-na\-že\-ra je
znázorněn diagramem na obrázku \ref{figure:parasim:lifecycle}.

\begin{figure}[h!]
\begin{center}
\resizebox{\textwidth}{!}{
\begin{tikzpicture}  	[node distance=.5cm,start chain=going below]
\tikzset{>=stealth',
	event/.style={
    	rectangle, 
    	rounded corners, 
    	fill=green!20,
    	draw=black, very thick,
    	text width=9em, 
    	minimum height=3em, 
    	text centered, 
    	on chain},
  	line/.style={draw, thick, <-},
	class/.style={
    	rectangle, 
    	rounded corners, 
    	fill=black!10,
    	draw=black, very thick,
    	text width=8em, 
    	minimum height=3em, 
    	text centered,
		on chain},
	package/.style={
		rectangle,
		draw=black!50, dashed,
		rounded corners,
		inner sep=0.3cm,
		on chain},
  	every join/.style={->, thick,shorten >=1pt}, 	
 	scope/.style={decorate},
	code/.style={
		rectangle,
		draw=black!50, dashed,
		rounded corners,
		text width=15em,
    	minimum height=3em, 
    	text centered,
		node distance=7cm}
}
	\node[event, join] (before-app-context) {BEFORE\\kontext aplikace};
	\node[event, join] (processing) {PROCESSING};
	\node[code, left of=before-app-context] (code-create) {Manager m = Manager.create()};
	\node[package] (processing-package) {
		\begin{tikzpicture}
		\begin{scope}[solid, start branch=venstre, every join/.style={->, thick, shorten <=1pt}]
			\node[class] (enrichment) {obohacování};
			\node[class, on chain=going left] (configuration) {konfigurace};
			\node[class, on chain=going below] (lifecycle) {životní cyklus};
			\node[class, on chain=going right] (extension-loader) {načtení rozšíření};
			\node[class, on chain=going right] (remote) {vzdálená správa};
			\node[class, on chain=going above] (logging) {logování};
		\end{scope}
		\end{tikzpicture}
	};
	\node[event, join] (started) {STARTED};
	\node[code, left of=started] (code-start) {m.start()};
	\node[package, join, inner sep=0.5cm, text width=15em, text centered] (other-extensions) {interakce s načtenými rozšířeními};
	\node[package, join, inner sep=0.5cm, text width=15em, text centered] (main-app) {hlavní kód aplikace};
	\node[event, join] (stopping) {STOPPING};
	\node[event, join] (after-app-context) {AFTER\\kontext aplikace};
	\node[code, left of=stopping] (code-shutdown) {m.destroy()};

	\begin{scope}[->, thick, shorten <=1pt] 
		\draw	(processing)	-> (processing-package);
	\end{scope}

	\begin{scope}[->, dashed, shorten <=1pt] 
		\draw	(code-create)	-> (before-app-context);
		\draw	(code-start)	-> (started);
		\draw	(code-shutdown)	-> (stopping);
	\end{scope}
\end{tikzpicture}}
\end{center}
\caption{Životní cyklus Parasimu. Zelené obdélníky představují události, které se propagují napříč rozšířeními.
Šedými obdélníkymi je znázorněna základní funkcionalita. Čerchovaným ohraničením jsou vyznačeny části Java kódu.}
\label{figure:parasim:lifecycle}
\end{figure}

Jakmile je manažer vytvořen,
jsou načtena zá\-klad\-ní rozšíření, kterým je oznámena událost \href{https://github.com/sybila/parasim/blob/2.0.0.Final/core/src/main/java/org/sybila/parasim/core/event/ManagerProcessing.java}{\texttt{ManagerProcessing}}.
Poté je možné manažera nastartovat, což vyústí ve vytvoření aplikačního kontextu.
S vytvořením každého kontextu je spojena událost \href{https://github.com/sybila/parasim/blob/2.0.0.Final/core/src/main/java/org/sybila/parasim/core/event/Before.java}{\texttt{Before}}, která je propagovaná
do všech roz\-ší\-ře\-ní náležejících tomuto kontextu a v případě jiného než
aplikačního kontextu i do rozšíření kontextu rodičovského.
Po vytvoření aplikačního kontextu následuje událost \href{https://github.com/sybila/parasim/blob/2.0.0.Final/core/src/main/java/org/sybila/parasim/core/event/ManagerStarted.java}{\texttt{ManagerStarting}},
na kterou mohou reagovat rozšíření definovaná mimo jádro Parasimu. Jakmile aplikace skončí,
je nutné ma\-na\-že\-ra zničit. Následuje vyvolání poslední u\-dá\-los\-ti, na kterou mohou reagovat načtená rozšíření, \href{https://github.com/sybila/parasim/blob/2.0.0.Final/core/src/main/java/org/sybila/parasim/core/event/ManagerStopping.java}{\texttt{ManagerStopping}}
a zničení aplikačního konextu spojené s událostí \href{https://github.com/sybila/parasim/blob/2.0.0.Final/core/src/main/java/org/sybila/parasim/core/event/After.java}{After}, případně všech další dosud nezničených kontextů.

\subsection{Kontexty}

Manažer a objekty kontextů umožňují vytvářet nové kontexty skrze rozhraní \href{https://github.com/sybila/parasim/blob/2.0.0.Final/core/src/main/java/org/sybila/parasim/core/api/ContextFactory.java}{ContextFactory}.
Aby mohl Parasim od se\-be rozlišit jednotlivé kontexty, používá speciální anotace
rozsahů. Samotná deklarace takové anotace je označená anotací \href{https://github.com/sybila/parasim/blob/2.0.0.Final/core/src/main/java/org/sybila/parasim/core/annotation/Scope.java}{\texttt{Scope}},
jak je ukázáno ve zdrojovém kódu \ref{code:scope}.

\begin{lstlisting}[label={code:scope}, caption={Anotace rozsahu}]
@Scope
@Documented
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.TYPE)
public @interface Application {}
\end{lstlisting}

Když je k dispozici anotace rozsahu rozlišující kontext, je možné  vytvořit kontext
nový, jak je ukázáno v ukázce kódu \ref{code:context}. Vývojář je zodpovědný za to,
aby kontext zničil, když už jej nebude potřebovat, aby roz\-ší\-ře\-ním, která se nacházejí
v tomto kontextu, umožnil uvolnit zdroje.

\begin{lstlisting}[label={code:context}, caption={Vytvoření kontextu}]
// vytvori kontext Scope1
// s rodicovskym kontextem Application
Context context1 = manager.context(Scope1.class); 
// vytvori kontext Scope2
// s rodicovskym kontextem Scope1
Context context2 = context1.context(Scope2.class);
...
context2.destroy();
context1.destroy();
\end{lstlisting}

\subsection{Služby}

Základní funkcionalitou jádra Parasimu je poskytovat instance služeb, které jsou
vytvořeny pomocí rozšíření. Služby se definují pomocí rozhraní a může pro ně existovat
více implementací. Aby byl Parasim schopen od sebe rozlišit jednotlivé implementace,
používá kvalifikátory. Kva\-li\-fi\-ká\-tor je anotace, v jejíž deklaraci byla použita anotace
\href{https://github.com/sybila/parasim/blob/2.0.0.Final/core/src/main/java/org/sybila/parasim/core/annotation/Qualifier.java}{\texttt{Qualifier}}.

Pokud na daném místě aplikace není důležité, jaká implementace dané služby bude použita,
případě není známo, jaké kvalifikátory jsou vůbec k dispozici, je možné použít kvalifikátor
\href{https://github.com/sybila/parasim/blob/2.0.0.Final/core/src/main/java/org/sybila/parasim/core/annotation/Default.java}{\texttt{Default}}
pro výchozí implementaci. Je na autorovi rozšíření, aby poskytl smysluplnou výchozí implementaci
poskytované služby.

Příkladem vhodného použití kvalifikátorů je rozšíření poskytující
vý\-počet robustnosti pro danou formuli nad danou trajektorii chování. Zde je možné zavést
různé kvalikátory pro různé temporální logiky. Výchozí implementace takové služby
by měla být schopna spočítat robustnost pro všechny podporované typy temporálních logik,
Avšak je možné, že se v~takovéto implementaci bude nacházet méně efektivní algoritmus,
případě analýza předložené formule, což zbrzdí výpočet.

\begin{lstlisting}[label={code:qualifier}, caption={Kvalikátor}]
@Qualifier
@Target({
	ElementType.FIELD,
	ElementType.METHOD,
	ElementType.PARAMETER})
@Retention(RetentionPolicy.RUNTIME)
@Documented
public @interface Default {}
\end{lstlisting}

Manažer i kontexty implementují rozhraní \href{https://github.com/sybila/parasim/blob/2.0.0.Final/core/src/main/java/org/sybila/parasim/core/api/Resolver.java}{\texttt{Resolver}},
které umožňuje na základě rozhraní a kvalifikátoru získat instance dané služby.
Pokud se v daném kontextu nenachází žádné rozšíření poskytující danou službu,
je zavolán rodičovský kontext. 

\begin{lstlisting}[label={code:resolve}, caption={Získání instance služby}]
Manager manager = ...
Enrichment enrichment = manager.resolve(
		Enrichment.class,
		Default.class);
\end{lstlisting}

Parasim používá ještě jeden jednodušší typ služeb. Tyto služby jsou dostupné pouze
pomocí manažera, nelze je od sebe odlišit pomocí kvalifikátoru a nejsou závislé na konextu.
Manažer poskytuje všechny dostupné implementace daného rozhraní v jedné kolekci. Tento typ služeb
primárně  slouží k ovlivňování cho\-vání rozšíření. Lze pomocí nich například
poslouchat událostem z logování.

\subsection{Rozšíření}

Parasim je schopen načíst rozšíření, která jsou v době vytvoření manažera na \texttt{Java class path}.
Všechna rozšíření zatím použitá v aplikaci byla přibalena do souboru JAR aplikace pomocí sestavovacího
nástroje Maven, a proto jsou k dispozici bez dalšího nasta\-vo\-vá\-ní. Rozšíření musí obsahovat
následující části:

\begin{itemize}
	\item	alespoń jednu třidu, která implementuje rozhraní \href{https://github.com/sybila/parasim/blob/2.0.0.Final/core/src/main/java/org/sybila/parasim/core/spi/LoadableExtension.java}{LoadableExtension},
	\item	soubor \texttt{META-INF/services/org.sybila.parasim.core.spi.\\LoadableExtension} obsahující plné názvy všech tříd z daného roz\-ší\-ření implementující \href{https://github.com/sybila/parasim/blob/2.0.0.Final/core/src/main/java/org/sybila/parasim/core/spi/LoadableExtension.java}{LoadableExtension}, jeden název na jednom řád\-ku. 
\end{itemize}

Rozhraní \href{https://github.com/sybila/parasim/blob/2.0.0.Final/core/src/main/java/org/sybila/parasim/core/spi/LoadableExtension.java}{LoadableExtension}
obsahuje jedinou metodu, ve které je pře\-dán objekt pro registraci tříd rozšíření. Je možné
registrovat služby ne\-zá\-vi\-slé na kontextu a tzv. pozorovatele, což jsou třídy poskytující
služby a naslouchající událostem. Podrobnější příklad toho, jak rozšíření může vypadat,
se nachází v příloze \ref{appendix:extension}. Tato sekce obsahuje pouze vysvětlení
nej\-dů\-le\-ži\-těj\-ších konceptů.

Již zmínění pozorovatelé jsou schopni pomocí metod označených anotací \href{https://github.com/sybila/parasim/blob/2.0.0.Final/core/src/main/java/org/sybila/parasim/core/annotation/Provide.java}{\texttt{Provide}}
poskytovat instance služeb. V deklaraci metody se mohou na\-chá\-zet parametry,
které je manažer jádra Parasimu schopen vyhodnotit a injektovat. Tyto parametry
lze označovat kvalifikátory. V případě, že není žádný kvalifikátor k dispozici,
je pro vyhodnocení hodnoty parametru použit kvalifikátor \href{https://github.com/sybila/parasim/blob/2.0.0.Final/core/src/main/java/org/sybila/parasim/core/annotation/Default.java}{\texttt{Default}}.

V případě, že je manažer požádán, aby poskytl instanci služby, metoda poskytující danou službu je zavolána,
poskytnutý objekt propagován jako událost do všech dostupných rozšíření, a poté uložen pro případ,
že by byla služba požadována znovu. Výjimku tvoří poskytující metody, pro jejichž
návratový typ nelze vytvořit proxy\footnote{Typickým příkladem typů, pro které nelze vytvořit proxy, jsou finální třídy.}.
Takové poskytující metody jsou zavolány již během načítání rozšíření. Pokud v čase volání
poskytující metody nelze najít hodnoty pro všechny její parametry, dojde k vyhození výjimky a
pravděpodobně i k~pádu celé aplikace.

\begin{lstlisting}[label={code:provide:required}, caption={První metoda poskytující službu \texttt{Functionality}}]
/**
 * selze, pokud neni v aktualnim kontextu k dispozici 
 * retezec pro dosazeni za parametr metody
 */
@Provide
public Functionality provideFunctionality(
		String required) {

	return new FunctionalityImpl(required);
}
\end{lstlisting}

Jestliže chce autor rozšíření záviset na jiných službách pouze volně, lze použít 
u parametrů poskytujících metod anotace \href{https://github.com/sybila/parasim/blob/2.0.0.Final/core/src/main/java/org/sybila/parasim/core/annotation/Inject.java}{\texttt{Inject}} způsobem u\-ká\-za\-ným ve zdrojovém
kódu \ref{code:provide:optional}.

\begin{lstlisting}[label={code:provide:optional}, caption={Druhá metoda poskytující službu \texttt{Functionality}}]
/**
 * pokud neni v aktualnim kontextu k dispozici 
 * retezec pro dosazeni za parametr metody,
 * bude pouzita hodnota null
 */
@Provide
public Functionality provideFunctionality(
		@Inject(required=false) String optional) {

	return new FunctionalityImpl(optional);
}
\end{lstlisting}

Druhým typem metod v pozorovatelských třídách jsou metody na\-slou\-cha\-jí\-cí událostem.
Aby bylo možné tyto metody rozlišit, je první parametr těchto metod je označen anotací \href{https://github.com/sybila/parasim/blob/2.0.0.Final/core/src/main/java/org/sybila/parasim/core/annotation/Observes.java}{\texttt{Observes}}
a typ tohoto parametru určuje typ naslouchané události. Pro další parametry těchto metod platí
stejná pravidla jako pro parametry poskytujících metod. Pro odeslání vlastních událostí
je k dispozici služba \href{https://github.com/sybila/parasim/blob/2.0.0.Final/core/src/main/java/org/sybila/parasim/core/api/EventDispatcher.java}{\texttt{EventDispatcher}}.

\subsection{Konfigurace}

Jádro Parasimu nabízí jednoduchý způsob konfigurace jednotný pro všech\-na rozšíření
a tím vybízí jejich autory, aby ve svých rozšířeních umožnili konfigurací změnit
co nejvíce věcí. Zároveň je však kladen důraz na to, aby rozšíření bylo funkční 
samo o sobě bez toho, aby jej uživatel musel konfigurovat.

Pro autory rozšíření je k dispozici služba \href{https://github.com/sybila/parasim/blob/2.0.0.Final/core/src/main/java/org/sybila/parasim/core/api/configuration/ParasimDescriptor.java}{\texttt{ParasimDescriptor}},
která je schopná na základě názvu rozšíření vrátit hodnoty konfiguračních pro\-měn\-ných
ve formě řetězců, dále služba \href{https://github.com/sybila/parasim/blob/2.0.0.Final/core/src/main/java/org/sybila/parasim/core/api/configuration/ExtensionDescriptorMapper.java}{\texttt{ExtensionDescriptorMapper}} schopná namapovat hodnoty konfiguračních pro\-měn\-ných
do atributů u~objektu v Javě. Mapování umí automaticky převést řetězce
do nej\-pou\-ží\-va\-něj\-ších datových typů.

Autor rozšíření tedy vytvoří konfigurační třídu s atributy, jejichž názvy se shodují
s požadovanými názvy konfiguračních proměnných. Výchozí hodnoty těchto atributů jsou
zároveň výchozími hodnotami pro konfiguraci rozšíření. Ukázka toho, jak může vypadat
zpřístupnění konfigurace v~rozšíření je k dispozici v~příloze \ref{appendix:configuration}.

Při užívání aplikace lze konfiguraci lze změnit dvěma způsoby:

\begin{itemize}
	\item	Pomocí systémové proměnné \texttt{parasim.config.file} v Javě je mož\-né nastavit cestu k XML souboru.
			Výchozí cesta k tomuto souboru je nastavena na \uv{parasim.xml}. Tento soubor
			obsahuje pojmenované sekce a v těchto sekcích nastavení pro jednotlivé konfigurační
			pro\-měn\-né. Názvy proměnných se shodují s názvy atributů konfiguračních objektů.

	\item	Pro každou konfigurační proměnnou lze přepsat její hodnotu pomocí systémové
			proměnné v Javě, jejíž název je \texttt{parasim.<název roz\-ší\-ření>.<název konfugurační proměnné>}.
			Názvy on\-fi\-gu\-rač\-ních promměných i název rozšíření se zde uvádí v tečkové notaci, například pro atribut \texttt{timeUnit}
			a rozšíření \texttt{example} se bude sys\-té\-mo\-vá proměnná nazývat \texttt{parasim.example.time.unit}.
\end{itemize}

Pokud je nutné nějakou část konfigurace zpřístupnit
změnám nejen při startu aplikace, ale i při jejím běhu skrze systémové proměnné, je potřeba mít na paměti
okamžik, ve kterém se vytváří konfigurační objekt. Jakmile je totiž již konfigurační objekt vytvořen,
nelze hodnoty konfigurace jemu náležící změnit. Po změně systémové proměnné,
je možné si znovunačtení konfiguračního objektu vynutit zničením příslušnoho kontextu
a vy\-tvo\-ře\-ním nového. Na to však není vhodný aplikační kontext, protože jeho
zničení prakticky znamená vypnutí aplikace.

\subsection{Obohacování}\label{section:enrichment}

Aby nebylo nutné si na všech místech předávat instanci manežera, případně instance všech
potřebných služeb, nabízí Parasim rozšiřitelný mechanismus obohacování objektů.
To je umožněno pomocí služby \href{https://github.com/sybila/parasim/blob/2.0.0.Final/core/src/main/java/org/sybila/parasim/core/api/enrichment/Enrichment.java}{\texttt{Enrichment}}.
Tato služba spouští objety na kontextu nezávislých služeb \href{https://github.com/sybila/parasim/blob/2.0.0.Final/core/src/main/java/org/sybila/parasim/core/spi/enrichment/Enricher.java}{\texttt{Enricher}}
na dané instanci, které ji dokáží různým způsobem vylepšit. 

Jádro Parasimu obsahuje dvě implementace rozhraní \href{https://github.com/sybila/parasim/blob/2.0.0.Final/core/src/main/java/org/sybila/parasim/core/spi/enrichment/Enricher.java}{\texttt{Enricher}},
které umožní zpřístupnit poskytující metody a atributy podobně jako u rozšíření 
a které injektují služby do atributů. Za tímto účelem se používají již zmíněné anotace \href{https://github.com/sybila/parasim/blob/2.0.0.Final/core/src/main/java/org/sybila/parasim/core/annotation/Provide.java}{\texttt{Provide}} a \href{https://github.com/sybila/parasim/blob/2.0.0.Final/core/src/main/java/org/sybila/parasim/core/annotation/Inject.java}{\texttt{Inject}}.
Tyto anotace lze použít ve dvou nastaveních, v jednom nastavení bude při obohoacování
vyhozena výjimka, pokud poskytovaný případně injektovaný objekt není k dispozici.
Pokud je anotace použita s přiřazením \texttt{required=false}, výjimka se nevyhodí.

\subsection{Vzdálený přístup}\label{section:remote}

Další části práce ukážou, jak je možné Parasim použít k distribovanému počítání.
To je umožněno pomocí rozšíření pro vzdálený přístup, které zpří\-stup\-ňu\-je získání
některých služeb nacházejících se v aplikačním kontextu jiného vzdá\-le\-né\-ho stroje.
Na tomto stroji je nejprve nutné tuto funkcionalitu aktivovat skrze rozhraní \href{https://github.com/sybila/parasim/blob/2.0.0.Final/core/src/main/java/org/sybila/parasim/core/api/remote/Loader.java}{\texttt{Loader.java}},
jak je ukázáno ve zdrojovém kódu \ref{code:remote}. Ukázaný kód nastartuje server
pro práci s \textit{Remote Method Invocation}~\cite{grosso2001} a na tento server vystaví \href{https://github.com/sybila/parasim/blob/2.0.0.Final/core/src/main/java/org/sybila/parasim/core/api/remote/Loader.java}{\texttt{Loader.java}}.

\begin{lstlisting}[label={code:remote}, caption={Spuštění serveru}]
manager.resolve(Loader.class, Default.class)
	   .load(Loader.class, Default.class);
\end{lstlisting}
Ostatní stroje jsou pak schopny vynutit si vystavení služeb z aplikačního kontextu
tohoto stroje na tento server. Aby bylo možné službu vystavit, je nutné, aby implementovala
rozhraní \texttt{java.rmi.Remote}. Jakmile je server na vzdáleném stroji aktivován,
je možné s ním komunikovat podobně jako ve zdrojovém kódu \ref{code:host:control}.

\begin{lstlisting}[label={code:host:control}, caption={Přístup ke vzdálenému serveru}]
HostControl control = new HostControlImpl(
		new URI("localhost"))

if (!control.isRunning(true)) {
	throw new IllegalStateException();
}

RemoteServis servis = control
		.lookup(RemoteServis.class, Default.class);
\end{lstlisting}

Jakákoliv interakce s takto získanými službami vyvolá síťovou komunikaci a veškerá logika
služby se vyhodnocuje na straně vzdáleného stroje.

\section{Výpočetní model}

Parasim obsahuje rozšíření pro snadnější provádění jistého druhu vý\-poč\-tu.
Základní jednotku výpočtu zde představuje instance. Během průběhu po\-čí\-tá\-ní lze
tuto instance rozdělit na více dalších a ty počítat nezávisle na sobě. Jednotlivé instance
se mohou dále dělit a vrací mezivýsledky, které je možné slučovat pomocí asociativní
a komutativní operace. Jak přesně se výpočetní instance dělí a jak jsou mezivýsledky
slučovány, určuje ten, kdo implementuje algoritmus.

Důležitým aspektem však je, že se vývojář implementující algoritmus nemusí starat
o způsob, jakým konkrétně budou výpočetní instance spočteny. To na druhou stranu vynucuje
některá omezení, která musí vývojář při implementaci výpočtu dodržet.  Parasim zatím nabízí
jednotné rozhraní pro počítání ve sdílené a~dís\-tri\-buo\-va\-né paměti.

\subsection{Reprezentace výsledku}

Třída reprezentující výsledek pro daný výpočet musí implementovat rozhraní \href{https://github.com/sybila/parasim/blob/2.0.0.Final/model/core/src/main/java/org/sybila/parasim/model/Mergeable.java}{\texttt{Mergeable}}. Toto rozhraní si vynucuje krom uchování dat také definci komutativní
a asociativní operace pro slučování mezivýsledků. Sou\-čas\-ně je nezbytné, aby třída
byla schopna serializace. Serializace je nezbytná pro výpočet v dis\-tri\-buo\-va\-né paměti,
kde se data po skončení mezivýpočtu po\-sí\-la\-jí mezi počítači po síti.

Z formálního hlediska již není kladen na datový typ výsledku žádný požadavek, nicméně
je třeba mít na paměti, že se mezivýsledek v případě distribuovaného počítání
serializuje a je mezi stroji posílán po síti, tudíž velikost mezivýsledků může velkou měrou
ovlivnit výpočetní čas. Podobně i metoda pro slučování mezivýsledků by neměla být vý\-po\-čet\-ně
příliš náročná, protože spojování výsledků má zpravidla na starost jedno vlákno, respektive
jeden stroj.

\subsection{Reprezentace výpočtu}

Jakýkoliv výpočet je v Parasimu definován jako třída implementující rozhraní \href{https://github.com/sybila/parasim/blob/2.0.0.Final/extensions/computation-lifecycle-api/src/main/java/org/sybila/parasim/computation/lifecycle/api/Computation.java}{\texttt{Computation}}. Ve třídě vývojář
implementuje algoritmus výpočtu za pomoci injektovaných služeb. V případě potřeby
lze určit způsob, jakým se má instance zachovat ve chvíli, kdy již není za potřebí.

V případě distribuovaného počítání se instance výpočtu může i ně\-ko\-lik\-rát posílat mezi stroji po sítí. Z toho důvodu
je nutné, aby i třída definující výpočet byla serializovatelná. To v praxi znamená, že musí
být seriazovatelné i hodnoty všech atributů, které nejsou injektovány. Bohužel chybová hláška z virtuálního stroje Javy
není v případě, že třída nesplňuje podmínky serializovatelnosti, přílíš popisná, takže
zejména tento typ chyb se velice špatně opravuje.

\subsection{Životní cyklus výpočtu}

Vstupním bodem pro spuštění výpočtu je služba \href{https://github.com/sybila/parasim/blob/2.0.0.Final/extensions/computation-lifecycle-api/src/main/java/org/sybila/parasim/computation/lifecycle/api/ComputationContainer.java}{\texttt{ComputationContainer}}. Tento kontejner rozhoduje
rozhoduje, jaké použít prostředí pro výpočet na základě dostupné konfigurace a anotací.
Pomocí anotace \href{https://github.com/sybila/parasim/blob/2.0.0.Final/extensions/computation-lifecycle-api/src/main/java/org/sybila/parasim/computation/lifecycle/api/annotations/RunWith.java}{\texttt{RunWith}} lze zvolit mezi prostředím se sdílenou nebo distribuovanou pamětí. Pokud tato anotace
není k dispozici, je použito výchozí prostředí, které lze předefinovat globálně v konfiguraci
Parasimu.

Jakmile kontejner provedl analýzu výpočetní instance, předává tuto instance dále
ke zvolenému výpočetnímu prostředí, ve kterém se instance spustí. Toto prostředí
vytvoří kontext výpočtu, který je sdílen napříč celým výpočtem na
jednom stroji. Pozor, v případě prostředí s distribuovanou pamětí, se tento kontext
vytvoří na každém použitém stroji. Tento kontext je vhodný pro bezstavové služby
a cache, do které si jednotlivé výpočetní instance mohou ukládat informace, jejichž
získání je vý\-po\-čet\-ně náročné. Například u algoritmu pro analýzu dynamických systémů
se v tomto kontextu nacházejí již nasimulované trajektorie chování nebo služba schopná spočítat
pro trajektorii chování její lokální robustnost.

Pro každou výpočetní instanci je dále vytvořen další kontext, který již není sdílený
s žádnou další instancí a jehož délka trvání může být  mnohem kratší než u výpočetního kontextu.
Tento kontext je vhodný pro služby, které by v případě sdílení napříč více vláken musely
být synchronizovány. V Parasimu se v tomto kontextu nachází služba pro simulaci trajektorie
chování, která pro tento účel používá proces nástroje GNU Octave \cite{eaton2008}. Není
žádoucí, aby jeden proces nástroje GNU Octave byl sdílen více vlákny. 

Aby se usnadnilo použití služeb z různých rozšíření, je před samotným spuštěním výpočetní
instance použito obohacování zmíněné v sekci \ref{section:enrichment}. Až po tomto bodu
se instance výpočtu spustí. Do této chvíle se v kontejneru nenachází žádná souběžnost
a vše je prováděno pouze sekvenčně. V~těle výpočtu však mohou být vytvářeny další instance výpočtu,
a ty pak pomocí asynchronního volání služby \href{https://github.com/sybila/parasim/blob/2.0.0.Final/extensions/computation-lifecycle-api/src/main/java/org/sybila/parasim/computation/lifecycle/api/Emitter.java}{\texttt{Emitter}} emitovány do výpočetního prostředí, které je zodpovědné za jejich spuštění.
Průběh počítání je tudíž podobný jako u modelu Fork/Join \cite{lea2000} uvedeného v Javě verze 7.

\begin{figure}[H]
\label{figure:computation:shared:memory}
\begin{center}
\resizebox{0.9\textwidth}{!}{
\begin{tikzpicture}  	[node distance=1.8cm,start chain=going below]
\tikzset{>=stealth',
	event/.style={
    	rectangle, 
    	rounded corners, 
    	fill=green!20,
    	draw=black, very thick,
    	text width=9em, 
    	minimum height=3em, 
    	text centered},
	class/.style={
    	rectangle, 
    	rounded corners, 
    	fill=black!10,
    	draw=black, very thick,
    	text width=9em, 
    	minimum height=3em, 
    	text centered},
	package/.style={
		rectangle,
		draw=black!50, dashed,
		rounded corners,
		inner sep=0.3cm},
 	scope/.style={decorate},
	code/.style={
		rectangle,
		draw=black!50, dashed,
		rounded corners,
    	text width=12em, 
    	minimum height=3em, 
    	text centered},
	dot/.style={
		circle,
		draw=black,
		fill=black,
		inner sep=0pt,
		minimum size=1pt
	}
}
	\node[class] (computation) {Computation comp\\instance výpočtu};
	\node[code, below of=computation] (compute) {ComputationContainer\\.compute(comp)};
	\node[code, below of=compute] (execute) {Executor.submit(comp)};
	\node[event, below of=execute] (before-computation) {BEFORE\\kontext výpočtu};
	\node[event, below of=before-computation] (before-computation-instance-1) {BEFORE\\kontext\\instance výpočtu};
	\node[code, below of=before-computation-instance-1] (computation-enrichment-1) {obohacení};
	\node[code, below of=computation-enrichment-1] (thread-pool-executor-execute-1) {výpočet};
	\node[class, below of=thread-pool-executor-execute-1] (result-partial-1) {mezivýsledek};
	\node[code, below of=result-partial-1] (computation-instance-destroy-1) {zničení};
	\node[event, below of=computation-instance-destroy-1] (after-computation-instance-1) {AFTER\\kontext\\instance výpočtu};
	\node[event, below of=after-computation-instance-1] (after-computation) {AFTER\\kontext výpočtu};
	\node[class, below of=after-computation] (result) {výsledek};

	\node[class, left of=before-computation-instance-1, node distance=6.5cm] (computation-copy-2) {instance výpočtu};
	\node[event, below of=computation-copy-2] (before-computation-instance-2) {BEFORE\\kontext\\instance výpočtu};
	\node[code, below of=before-computation-instance-2] (computation-enrichment-2) {obohacení};
	\node[code, below of=computation-enrichment-2] (thread-pool-executor-execute-2) {výpočet};
	\node[class, below of=thread-pool-executor-execute-2] (result-partial-2) {mezivýsledek};
	\node[code, below of=result-partial-2] (computation-instance-destroy-2) {zničení};
	\node[event, below of=computation-instance-destroy-2] (after-computation-instance-2) {AFTER\\kontext\\instance výpočtu};

	\node[class, right of=before-computation-instance-1, node distance=6.5cm] (computation-copy-3) {instance výpočtu};
	\node[event, below of=computation-copy-3] (before-computation-instance-3) {BEFORE\\kontext\\instance výpočtu};
	\node[code, below of=before-computation-instance-3] (computation-enrichment-3) {obohacení};
	\node[code, below of=computation-enrichment-3] (thread-pool-executor-execute-3) {výpočet};
	\node[class, below of=thread-pool-executor-execute-3] (result-partial-3) {mezivýsledek};
	\node[code, below of=result-partial-3] (computation-instance-destroy-3) {zničení};
	\node[event, below of=computation-instance-destroy-3] (after-computation-instance-3) {AFTER\\kontext\\instance výpočtu};

	\node[dot, left of=thread-pool-executor-execute-1, node distance=3cm] (line11) {};
	\node[dot, left of=before-computation-instance-1, node distance=3cm, label=above left:emit] (line12) {};
	\node[dot, right of=thread-pool-executor-execute-1, node distance=3cm] (line21) {};
	\node[dot, right of=before-computation-instance-1, node distance=3cm, label=above right:emit] (line22) {};

	\begin{scope}[->, thick]
		\draw (computation) -> (compute);
		\draw (compute) -> (execute);
		\draw (execute) -> (before-computation);
		\draw (after-computation) -> (result);

		\draw (before-computation) -> (before-computation-instance-1);

		\draw (before-computation-instance-1) -> (computation-enrichment-1);
		\draw (before-computation-instance-2) -> (computation-enrichment-2);
		\draw (before-computation-instance-3) -> (computation-enrichment-3);

		\draw (computation-copy-2) -> (before-computation-instance-2);
		\draw (computation-copy-3) -> (before-computation-instance-3);

		\draw (computation-enrichment-1) -> (thread-pool-executor-execute-1);
		\draw (computation-enrichment-2) -> (thread-pool-executor-execute-2);
		\draw (computation-enrichment-3) -> (thread-pool-executor-execute-3);

		\draw (thread-pool-executor-execute-1) -> (result-partial-1);
		\draw (thread-pool-executor-execute-2) -> (result-partial-2);
		\draw (thread-pool-executor-execute-3) -> (result-partial-3);

		\draw (result-partial-1) -> (computation-instance-destroy-1);
		\draw (result-partial-2) -> (computation-instance-destroy-2);
		\draw (result-partial-3) -> (computation-instance-destroy-3);

		\draw (computation-instance-destroy-1) -> (after-computation-instance-1);
		\draw (computation-instance-destroy-2) -> (after-computation-instance-2);
		\draw (computation-instance-destroy-3) -> (after-computation-instance-3);

		\draw (after-computation-instance-1) -> (after-computation);
		\draw (after-computation-instance-2) -> (after-computation);
		\draw (after-computation-instance-3) -> (after-computation);

		\draw (line12) -> (computation-copy-2);

		\draw (line22) -> (computation-copy-3);
	\end{scope}
	\begin{scope}[thick]
		\draw (thread-pool-executor-execute-1) -- (line21);
		\draw (line21) -- (line22);
		\draw (thread-pool-executor-execute-1) -- (line11);
		\draw (line11) -- (line12);
	\end{scope}
\end{tikzpicture}}
\end{center}
\caption{Schéma průběhu výpočtu ve sdílené paměti. Zelené obdelníky představují události,
šedými obdelníkymi objekty a čerchovaně ohraničené jsou části Java kódu.}
\end{figure}

Jakmile je výpočetní instance s výpočtem hotová, je vrácen výsledek a~zničí se
kontext spojený s touto instancí. Kontejner sbírá mezivýsledky a~postupně je slučuje
s dalšími. Až svůj výpočet ukončí poslední instance, zničí se výpočetní kontext na
všech použitých strojích. Konečný výsledek, případně i aktuální podoba sloučených
mezivýsledků je v~aplikaci k dispozici v podobě objektu \href{https://github.com/sybila/parasim/blob/2.0.0.Final/extensions/computation-lifecycle-api/src/main/java/org/sybila/parasim/computation/lifecycle/api/Future.java}{\texttt{Future}}.

\subsection{Výpočetní prostředí}

Jak již bylo řečeno, Parasim nabízí dva typy prostředí, ve kterém lze výpočet spustit.
Výchozí prostředím, které bude použito bez jakéhokoliv na\-sta\-vo\-vá\-ní, je počítání ve sdílené paměti.
Toto prostředí využívá standardního způsobu nepřímé práce s vlákny ve virtuálním stroji Javy
pomocí třídy implementující \texttt{java.util.concurrent.ExecutorService}.
Instance té\-to třídy má k dispozici určité množství vláken, která jsou v~kapitole
\ref{chapter:evaluation} označována jako výpočetní. Těmto vláknům se posílají ke
zpracování objekty implementující \texttt{java.util.concurrent.Callable}.

Takto odeslané objekty \texttt{java.util.concurrent.Callable} již nelze získat zpět,
což způsobuje drobné komplikace. Aby bylo možné model pro sdílenou paměť převyužít i pro prestředí s distribuovanou pamětí,
je zapotřebí u\-mož\-nit balancovat výpočet napříč více stroji. V případě, že některý ze strojů není vytížený, kontejner zajistí,
aby se na tento stroj přesunula instance výpočtu ze stroje více vytíženého. Z toho důvodu
obsahuje Parasim mezivrstvu (třída \href{https://github.com/sybila/parasim/blob/2.0.0.Final/extensions/computation-lifecycle-impl/src/main/java/org/sybila/parasim/computation/lifecycle/impl/common/Mucker.java}{\texttt{Mucker}}). Instance výpočtu jsou nejprve uloženy do fronty a objektu \texttt{java.util.concurrent.ExecutorService}
jsou dále posílány z této fronty tak, aby dostupná vlánka byla co nejvíce vytížená.
Pokud dojde k přesouvání instancí výpočtu mezi stroji, jsou k~tomu využity instance z fronty daného stroje.

Centrálním bodem výpočtu je třída implementující \href{https://github.com/sybila/parasim/blob/2.0.0.Final/extensions/computation-lifecycle-api/src/main/java/org/sybila/parasim/computation/lifecycle/api/MutableStatus.java}{\texttt{MutableStatus}}. Skrze tento bod se dorozumívají všechny objekty
starající se o řádný průběh počítání. Využívají k~tomu systém událostí a naslouchajících objektů
implementujících rozhraní \href{https://github.com/sybila/parasim/blob/2.0.0.Final/extensions/computation-lifecycle-api/src/main/java/org/sybila/parasim/computation/lifecycle/api/ProgressListener.java}{\texttt{ProgressListener}}. Použité události jsou:

\begin{description}

    \item[emitted] 		Událost nastane ve chvíli, kdy je emitován nový výpočet pomocí služby
						\href{https://github.com/sybila/parasim/blob/2.0.0.Final/extensions/computation-lifecycle-api/src/main/java/org/sybila/parasim/computation/lifecycle/api/Emitter.java}{\texttt{Emitter}}.

    \item[computing] 	Událost nastane ve chvíli, kdy je instance výpočtu z fronty vý\-poč\-tů poslána
						vláknů k provedení a ještě před tím, než je pro instanci vytvořen příslušný kontext.

    \item[done] 		Událost nastane ve chvíli, kdy je instance výpočtu se svým výpočtem
						hotova. Stane se tak ještě před tím, než je vrácen výsledek,
						zničen kontext a zničena instance.

	\item[finished]		Událost nastane ve chvíli, kdy již není k dispozici žádná instance výpočtu.
	
	\item[balanced]		Událost nastane ve chvíli, kdy dojde k přesunutí instance výpočtu z jednoho stroje na jiný,
						a to pouze na stroji, kam byla instance pře\-su\-nu\-ta.
\end{description}

V případě prostředí s distribuovanou pamětí je průběh výpočtu slo\-ži\-těj\-ší. Než začne samotný výpočet,
je nutné na strojích, které chceme použít, spustit podporu pro vzdálený přístup
zmíněný v sekci \ref{section:remote}. Na každém z~těch\-to strojů je výpočet zaregistrován
pod náhodným identifikátorem a vytvoří se výpočetní kontext. V celém mechanismu se tedy  nacházejí dva typy strojů --
stroj, ze kterého byl výpočet iniciován (\textit{master}), a stroje, mezi které je distribuovaná práce (\textit{slave}).

\begin{figure}[h!]
\label{figure:computation:events}
\begin{center}
\resizebox{0.95\textwidth}{!}{
\begin{tikzpicture}  	[node distance=1.8cm,start chain=going below]
\tikzset{>=stealth',
	event/.style={
    	rectangle, 
    	rounded corners, 
    	fill=green!20,
    	draw=black, very thick,
    	text width=9em, 
    	minimum height=3em, 
    	text centered},
	class/.style={
    	rectangle, 
    	rounded corners, 
    	fill=black!10,
    	draw=black, very thick,
    	text width=9em, 
    	minimum height=3em, 
    	text centered},
	package/.style={
		rectangle,
		draw=black!50, dashed,
		rounded corners,
		inner sep=0.3cm},
 	scope/.style={decorate},
	code/.style={
		rectangle,
    	text width=9em, 
		draw=black!50, dashed,
		rounded corners,
    	minimum height=3em, 
    	text centered}
}
	\node[class] (computation-instance) {instance výpočtu};
	\node[event, below left of=computation-instance, node distance=3.5cm] (computing) {COMPUTING};
	\node[event, left of=computing, node distance=4.9cm] (emitted) {EMITTED};
	\node[event, below right of=computation-instance, node distance=3.5cm] (balanced) {BALANCED};
	\node[event, right of=balanced, node distance=4.9cm] (done) {DONE};
	\node[event, below of=computation-instance, node distance=7cm] (finished) {FINISHED};

	\node[code, below of=computing] (executor-service) {ExecutorService};

	\node[package, below of=emitted, node distance=4cm] (emitted-listeners) {
		\begin{tikzpicture}
			\begin{scope}[node distance=1.8cm, solid]
				\node[class] (distributed-mucker-1) {DistributedMemory\\Mucker};
				\node[class, below of=distributed-mucker-1] (mucker-1) {Mucker};
				\node[class, below of=mucker-1] (offerer) {Offerer};
			\end{scope}
		\end{tikzpicture}
	};

	\node[package, below of=done, node distance=4cm] (done-listeners) {
		\begin{tikzpicture}
			\begin{scope}[node distance=1.8cm, solid]
				\node[class] (distributed-mucker-2) {DistributedMemory\\Mucker};
				\node[class, below of=distributed-mucker-2] (mucker-2) {Mucker};
				\node[class, below of=mucker-2] (computation-future) {ComputationFuture};
			\end{scope}
		\end{tikzpicture}
	};

	\begin{scope}[->, thick]
		\draw (computation-instance) -> (computing);
		\draw (computation-instance) -> (emitted);
		\draw (computation-instance) -> (balanced);
		\draw (computation-instance) -> (done);
		\draw (emitted) -> (emitted-listeners);
		\draw (computing) -> (executor-service);
		\draw (done) -> (done-listeners);
		\draw (computation-instance) -> (finished);
	\end{scope}
\end{tikzpicture}}
\end{center}
\caption{Schéma událostí, které nastávají během výpočtu, a objektů, které na tyto události reagují.}
\end{figure}


Narozdíl od prostředí se sdílenou pamětí se zde nacházejí syn\-chro\-ni\-zač\-ní body dva.
Výpočet na každém \textit{slave} stroji řídí lokální status, který skrze události volá příslušné objekty
nutné k obsluze lokálního výpočtu. Tento lokální status ještě před tím, než zavolá naslouchající objekty
implementující rozhraní \href{https://github.com/sybila/parasim/blob/2.0.0.Final/extensions/computation-lifecycle-api/src/main/java/org/sybila/parasim/computation/lifecycle/api/ProgressListener.java}{\texttt{ProgressListener}}, kontaktuje s příslušnou událostí vzdá\-le\-ný status nacházející se na stroji \textit{master}.
Status na \textit{master} stroji před\-sta\-vu\-je synchronizační bod pro všechny stroje participující
na da\-ném vý\-poč\-tu. Díky tomu, že je kontaktován při každé výpočetní události, může \textit{master} stroj
balancovat výpočetní instance napříč \textit{slave} stroji. K tomuto účelu používá objekt \href{https://github.com/sybila/parasim/blob/2.0.0.Final/extensions/computation-lifecycle-impl/src/main/java/org/sybila/parasim/computation/lifecycle/impl/distributed/DistributedMemoryMucker.java}{\texttt{DistributedMemoryMucker}}.


\subsection{Možná nastavení výpočtu}

Jednotlivé výpočty se od sebe mohou velkou mírou lišit, a je proto vhodné, aby celý mechanismus
počítání v Parasimu byl co nejsnáze nastavitelný. Jednou z věcí, která může výpočet ovlivnit, je pořadí,
v jakém se jednotlivé instance budou počítat. Dalším důležitým faktorem může být výběr instance,
která se přesune při balancování mezi méně a více vytíženým strojem. Tyto dva atributy se zdají být
kritické pro implementaci uvažovaného algoritmu pro analýzu dynamického systému, protože obsahuje
výpočetně velice náročnou numerickou simulaci, kvůli které je vhodné používat cache.

Ukládání trajektorií chování je paměťově poměrně náročné, a proto se po nějaké době
musí trajektorie z paměti vymazat. Pokud se výpočetní instance pro\-vá\-dě\-jí v pořadí daném
iterací zahušťování, je možné některé trajektorie vymazat z paměti dříve. V případě virtuálního
stroje Javy se navíc menší využití paměti projeví i na výkonu \textit{Garbage collector} \cite{printezis2000}. 

Pokud přesouváme jednu výpočetní instanci z jednoho stroje na druhý, je třeba si uvědomit,
že každý z těchto strojů má již vybudovanou svoji cache. Cílem balancování je přesunout
nejlépe takovou výpočetní instanci, která bude pracovat s trajektoriemi nenacházejícími
se v cache zdrojového stroje. Výpočet takové instance bude na cílovém stroji trvat nejvíce tak dlouho jako
na stroji zdrojovém.

Parasim k tomuto účelu nabízí rozhraní \href{https://github.com/sybila/parasim/blob/2.0.0.Final/extensions/computation-lifecycle-api/src/main/java/org/sybila/parasim/computation/lifecycle/api/Selector.java}{\texttt{Selector}}, které z dané kolekce vybere jeden její prvek. Pomocí anotace \href{https://github.com/sybila/parasim/blob/2.0.0.Final/extensions/computation-lifecycle-api/src/main/java/org/sybila/parasim/computation/lifecycle/api/annotations/RunWith.java}{\texttt{RunWith}} lze nastavit třídu implementující toto rozhraní
pro účely balancování nebo výběru instance pro další počítání. U těchto objektů je opět použito mechanismu obohacování ze sekce \ref{section:enrichment},
a tudíž mají k dispozici všechny služby z výpočetního kontextu na daném stroji.
Vývojář však musí mít na paměti, že se tyto objekty budou volat velice často, 
a proto by výběr z kolekce neměl být příliš výpočetně náročný.


\section{Dostupná rozšíření}

Na závěr této kapitoly je vhodné uvést rozšíření, která jsou zatím pro účely aplikace
implementující algoritmus pro analýzu dynamických systémů dostupná. Zde je uveden pouze výčet
s krátkým popisem. Možné způsoby konfigurace jsou k dispozici v příloze \ref{appendix:extensions}.

\begin{description}

	\item[computation-simulation] 		Rozšíření poskytuje numerickou simulaci. Pro se\-kven\-ci bodů vrátí
										sekvenci trajektorií chování. Umožňuje rovněž již nasimulovanou trajektorii
										chování prodloužit o zvolený čas. Současná implementace použivá volně dostupný
										nástroj GNU Octave~\cite{eaton2008}. 

    \item[computation-cycledetection]	Rozšíření pro detekci cyklu na trajektorii cho\-vá\-ní. V současné
										implementaci nástroje toto rozšížení není použito. Nicméně ostatní
										rozšíření jsou schopna s výsledky analýzy pracovat. Od detekování
										cyklu se upustilo z důvodu použití konečných intervalů u
										temporálních operátorů ve zkoumaných vlastnostech.

    \item[computation-density]			Rozšíření dokáže určit vzdálenosi mezi hlavní trajektorií a sousedními trajektoriemi chování a na
										základě této vzdá\-le\-nos\-ti zahustit prostor iniciálních podmínek. Obsahuje cache pro
										již použité trajektorie. Z důvodu nepřesnosti při počítání s reálnými čísly v Javě se
										se jako klíč v této paměti používají souřadnice obsahující zlomky, jejichž jmenovatel
										je mocninou čísla 2. Tento zlomek určuje v jaké části prostoru iniciálních podmínek,
										který je po celou dobu výpočtu stejně velký, se trajektorie chování nachází.

	\item[computation-lifecycle]		Rozšíření poskytující již dříve zmíněný výpočetní model použitý v Parasimu. 

\end{description}

V současné době Parasim obsahuje více rozšíření, než je zde zmíněno. Nicméně tato rozšíření se vztahují ne k samotnému
algoritmu, ale spíše k~samotné aplikaci. Tato aplikace umí spravovat projekty s modely a nastavením
pro analýzu. Také umožňuje výsledky analýzy zobrazovat a ukládat do souboru.
