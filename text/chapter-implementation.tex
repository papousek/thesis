\chapter{Implementace}
Následující kapitola se věnuje aplikaci Parasim \cite{TODO}, která implementuje algoritmus pro
analýzu dynamických systémů zmíněný v sekci \ref{section:algorithm:updated}. Aplikace Parasim
vznikla na základě prototypu dostupného v \cite{drazan2011}. Cílem prototypu je názorně
zobrazit průběh výpočtu původního algoritmu. Uživateli se ukazuje, jakým způsobem
se počítá vzdálenost mezi trajektoriemi chování, kde je nutné zahušťovat a jak dopadlo
ověření platnosti. Vzhledem k tomu, že prototyp například používá pouze jednoduchou metodu
numerické simulace k nalezení trajektorií chování, není vhodné jej použít k analýze složitějších modelů.

V nové implementaci bylo oproti prototypu třeba zahrnout následující:

\begin{enumerate}
	\item	úprava algoritmu dle sekce \ref{section:algorithm:updated},
	\item	paralelní výpočet ve sdílené nebo distribuované paměti,
	\item	rozšiřitelnost, modularita a otevřenost k rozdílné implementaci již naimplementovaných částí,\label{item:features:extensibility}
	\item	zobrazení výsledků analýzy pro vícedimenzionální prostory ini\-ciál\-ních podmínek.\label{item:features:visualisation}
\end{enumerate}

Tato práce se zabývá všemi zmíněnými body kromě bodu \ref{item:features:visualisation},
který je však v Parasimu již také vyřešen. Vzhledem k monolitické implementaci prototypu
nedošlo k jeho úpravám a rozšíření, ale vytvořila se zcela od základu nová aplikace Parasim.
Bod \ref{item:features:extensibility} je důležitý z několika důvodů. Pro různé části algoritmu
existuje více způsobů, jak je naimplementovat. Existuje mnoho nástrojů umožňující
numerickou simulací na základě systému diferenciálních rovnic získat trajektorii chování.
Mnoho věcí zmíněných dříve se vyvíjí. V případě výpočtu robustnosti se nemusíme omezit
pouze na temporální logiku signálů, ale můžeme zavést logiku novou, expresivněj\-ší.

\section{Architektura}

Parasim je aplikace napsaná v Javě 7 složená z většího množství artefaktů pro
sestavovací nástroj Maven. Zdrojové kódy jsou pod licencí GNU GPL verze 3~\cite{gpl} k dispozici
v Git \cite{chacon2009} repozitáři \url{https://github.com/sybila/parasim}. Artefakty sestavené
z poslední verze těchto zdrojových jsou publikovány do Maven repozitáře
\url{http://repository-sybila.forge.cloudbees.com/snapshot/}, o což se stará veřejná
instance nástroje Jenkins \cite{jenkins} \url{http://www.cloudbees.com/}. Artefakty
vydaných verzí jsou k nalezení v Maven repozitáři \url{http://repository-sybila.forge.cloudbees.com/release}.
Hlavní aplikaci Parasimu představuje artefakt \texttt{org.sybila.parasim.application:parasim}.
Pou\-ži\-tí aplikace je popsáno v příloze \ref{appendix:usage}

Jádro Parasimu tvoří artefakt \texttt{org.sybila.parasim:core}, který řídí ži\-vot\-ní
cyklus všech modulů a zajišťuje základní funkcionalitu. To zajišťuje kontejner,
jehož instance je vytvořena a spuštěn v rámci aplikace. Kontejner je velkou mírou inspi\-ro\-ván
konceptem \textit{Context and Dependency Injection} zavedeným v~Java~EE~6~\cite{jendrock2010} specifikací
JSR-299 \cite{jsr299}. V žádném případě se nejedná o~implementaci tohoto standardu,
nýbrž jen o volnou inspiraci některými zá\-klad\-ní\-mi myšlenkami.

Existují zde kontexty, které mají různou délku a je možné je za\-no\-řo\-vat.
Rozšíření pro jednotlivé kontexty nabízejí služby a aplikace definuje na různých
místech v kódu závislosti na těchto službách. Kontejner se stará o to,
aby v případě požadavku na nějakou službu bylo zavoláno příslušné rozříření,
které ji poskytuje, aby vytvořilo objekt služby, a v případě vy\-pr\-še\-ní kontextu,
aby objekt služby vhodným způsobem zničilo.

Za vytvoření a zničení objektu služby je zodpovědný autor rozšíření, který také definuje rozhraní
služby. Aplikace není téměř žádným způsobem závislá na implementaci rozhraní,
a jednotlivé implementace lze tak jednoduše zaměňovat bez toho, aniž bychom
v~aplikačním kódu cokoliv mě\-ni\-li. Kontejner obsahuje i některé základní služby,
mezi které patří například jednotný přístup ke konfiguraci nebo způsob, jak injektovat
služby do atributů daných objektů.

\subsection{Životní cyklus}

Aby bylo možné jádro Parasimu používat, je nutné nastartovat jeho životní cyklus pomocí třídy
\href{https://github.com/sybila/parasim/blob/master/core/src/main/java/org/sybila/parasim/core/impl/ManagerImpl.java}{\texttt{ManagerImpl}}.
Tato třída představuje vstupní bod pro použití všech dále popsaných služeb.
Životní cyklus řízený vytvořením, nastartováním a zničením manažera je
znázorněn diagramem \ref{figure:parasim:lifecycle}. Jakmile je manažer vytvořen,
jsou načtena zá\-klad\-ní rozšíření, kterým je oznámena událost \href{https://github.com/sybila/parasim/blob/master/core/src/main/java/org/sybila/parasim/core/event/ManagerProcessing.java}{\texttt{ManagerProcessing}}.

\begin{figure}[h!]
\label{figure:parasim:lifecycle}
\begin{center}
\resizebox{\textwidth}{!}{
\begin{tikzpicture}  	[node distance=.5cm,start chain=going below]
\tikzset{>=stealth',
	event/.style={
    	rectangle, 
    	rounded corners, 
    	fill=green!20,
    	draw=black, very thick,
    	text width=9em, 
    	minimum height=3em, 
    	text centered, 
    	on chain},
  	line/.style={draw, thick, <-},
	class/.style={
    	rectangle, 
    	rounded corners, 
    	fill=black!10,
    	draw=black, very thick,
    	text width=8em, 
    	minimum height=3em, 
    	text centered,
		on chain},
	package/.style={
		rectangle,
		draw=black!50, dashed,
		rounded corners,
		inner sep=0.3cm,
		on chain},
  	every join/.style={->, thick,shorten >=1pt}, 	
 	scope/.style={decorate},
	code/.style={
		rectangle,
		draw=black!50, dashed,
		rounded corners,
		text width=15em,
    	minimum height=3em, 
    	text centered,
		node distance=7cm}
}
	\node[event, join] (before-app-context) {BEFORE\\kontext aplikace};
	\node[event, join] (processing) {PROCESSING};
	\node[code, left of=before-app-context] (code-create) {Manager m = Manager.create()};
	\node[package] (processing-package) {
		\begin{tikzpicture}
		\begin{scope}[solid, start branch=venstre, every join/.style={->, thick, shorten <=1pt}]
			\node[class] (enrichment) {obohacování};
			\node[class, on chain=going left] (configuration) {konfigurace};
			\node[class, on chain=going below] (lifecycle) {životní cyklus};
			\node[class, on chain=going right] (extension-loader) {načtení rozšíření};
			\node[class, on chain=going right] (remote) {vzdálená správa};
			\node[class, on chain=going above] (logging) {logování};
		\end{scope}
		\end{tikzpicture}
	};
	\node[event, join] (started) {STARTED};
	\node[code, left of=started] (code-start) {m.start()};
	\node[package, join, inner sep=0.5cm, text width=15em, text centered] (other-extensions) {interakce s načtenými rozšířeními};
	\node[package, join, inner sep=0.5cm, text width=15em, text centered] (main-app) {hlavní kód aplikace};
	\node[event, join] (stopping) {STOPPING};
	\node[event, join] (after-app-context) {AFTER\\kontext aplikace};
	\node[code, left of=stopping] (code-shutdown) {m.destroy()};

	\begin{scope}[->, thick, shorten <=1pt] 
		\draw	(processing)	-> (processing-package);
	\end{scope}

	\begin{scope}[->, dashed, shorten <=1pt] 
		\draw	(code-create)	-> (before-app-context);
		\draw	(code-start)	-> (started);
		\draw	(code-shutdown)	-> (stopping);
	\end{scope}
\end{tikzpicture}}
\end{center}
\caption{Životní cyklus Parasimu. Zelené obdelníky představují události, které se propagují napříč rozšířeními.
Šedými obdelníkymi je znázorněna základní funkcionalita. Čerchovaně ohraničeně jsou vyznačeny části Java kódu.}
\end{figure}

Poté je možné manažera nastartovat, což vyústí ve vytvoření aplikačního kontextu.
S vytvořením každého kontextu je spojena událost \href{https://github.com/sybila/parasim/blob/master/core/src/main/java/org/sybila/parasim/core/event/Before.java}{\texttt{Before}}, která je propagovaná
do všech rozšíření náležejícím tomuto kontextu a v případě jiného než
aplikačního kontextu i do rozšíření kontextu rodičovského.
Po vytvoření aplikačního kontextu následuje událost \href{https://github.com/sybila/parasim/blob/master/core/src/main/java/org/sybila/parasim/core/event/ManagerStarted.java}{\texttt{ManagerStarting}},
na kterou mohou reagovat rozšíření definovaná mimo jádro Parasimu. Jakmile aplikace skončí,
je nutné manažera zničit. Následuje vyvolání poslední u\-dá\-los\-ti, na kterou mohou reagovat načtená rozšíření, \href{https://github.com/sybila/parasim/blob/master/core/src/main/java/org/sybila/parasim/core/event/ManagerStopping.java}{\texttt{ManagerStopping}}
a zničení aplikačního konextu spojené s událostí \href{https://github.com/sybila/parasim/blob/master/core/src/main/java/org/sybila/parasim/core/event/After.java}{After}, případně všech další dosud nezničených kontextů.

\subsection{Kontexty}

Manažer a objekty kontextů umožňují vytvářet nové kontexty skrze rozhraní \href{https://github.com/sybila/parasim/blob/master/core/src/main/java/org/sybila/parasim/core/api/ContextFactory.java}{ContextFactory}.
Aby mohl Parasim od se\-be rozlišit jednotlivé kontexty, používá speciální anotace
rozsahů. Deklarace takové anotace je samotná označená anotace \href{https://github.com/sybila/parasim/blob/master/core/src/main/java/org/sybila/parasim/core/annotation/Scope.java}{\texttt{Scope}},
jak je ukázáno ve zdrojovém kódu \ref{code:scope}.

\begin{lstlisting}[label={code:scope}, caption={Anotace rozsahu}]
@Scope
@Documented
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.TYPE)
public @interface Application {}
\end{lstlisting}

Když je k dispozici anotace rozsahu rozlišující kontext, je možné nový kontext vytvořit
nový, jak je ukázáno v ukázce kódu \ref{code:context}. Vývojář je zodpovědný za to,
aby kontext zničil, když už jej nebude potřebovat, aby roz\-ší\-ře\-ním umožnil uvolnit zdroje.

\begin{lstlisting}[label={code:context}, caption={Vytvoření kontextu}]
// vytvori kontext Scope1
// s rodicovskym kontextem Application
Context context1 = manager.context(Scope1.class); 
// vytvori kontext Scope2
// s rodicovskym kontextem Scope1
Context context2 = context1.context(Scope2.class);
...
context2.destroy();
context1.destroy();
\end{lstlisting}

\subsection{Služby}

Základní funkcionalitou jádra Parasimu je poskytovat instance služeb, které jsou
vytvořeny pomocí rozšíření. Služby se definují pomocí rozhraní a může pro ně existovat
více implementací. Aby byl Parasim schopen od sebe rozlišit jednotlivé implementace
různých vlastností používá kvalifikátory. Kva\-li\-fi\-ká\-tor je anotace, v jejíž deklaraci byla použita anotace
\href{https://github.com/sybila/parasim/blob/master/core/src/main/java/org/sybila/parasim/core/annotation/Qualifier.java}{\texttt{Qualifier}}.

Pokud na daném místě aplikace není důležité, jakou typ implementace služby požadovat,
případě není známo, jaké kvalifikátory jsou vůbec k dispozici, je možné použít kvalifikátor
\href{https://github.com/sybila/parasim/blob/master/core/src/main/java/org/sybila/parasim/core/annotation/Default.java}{\texttt{Default}}
pro výchozí implementaci. Je na autorovi rozšíření, aby poskytl smysluplnou výchozí implementaci
poskytované služby.

Příkladem vhodného použití kvalifikátorů je rozšíření poskytující
vý\-počet robustnosti pro danou formuli nad danou trajektorii chování. Zde je možné zavést
různé kvalikátory pro různé temporální logiky. Výchozí implementace takové služby
by měla být schopna spočítat robustnost pro všechny podporované typy temporálních logik,
Avšak je možné, že se v takovéto implementaci bude nacházet méně efektivní algoritmus,
případě nějaká analýza předložené formule, což zbrzdí výpočet.

\begin{lstlisting}[label={code:qualifier}, caption={Kvalikátor}]
@Qualifier
@Target({
	ElementType.FIELD,
	ElementType.METHOD,
	ElementType.PARAMETER})
@Retention(RetentionPolicy.RUNTIME)
@Documented
public @interface Default {}
\end{lstlisting}

Manažer i kontexty implementují rozhraní \href{https://github.com/sybila/parasim/blob/master/core/src/main/java/org/sybila/parasim/core/api/Resolver.java}{\texttt{Resolver}},
které umožňuje na základě rozhraní a kvalifikátoru získat instance dané služby.
Pokud se v daném kontextu nenachází žádné rozšíření poskytující danou službu,
je zavolán rodičovský kontext. 

\begin{lstlisting}[label={code:resolve}, caption={Získání instance služby}]
Manager manager = ...
Enrichment enrichment = manager.resolve(
		Enrichment.class,
		Default.class);
\end{lstlisting}

Parasim používá ještě jeden jednodušší typ služeb. Tyto služby jsou dostupné pouze
pomocí manažera a nelze je od sebe odlišit pomocí kvalifikátoru. Manežer poskytuje
všechny dostupné implementace daného rozhraní v jedné kolekci. Tento typ služeb
primárně  slouží k ovlivňování cho\-vání rozšíření. Lze pomocí nich například
poslouchat událostem z logování.

\subsection{Rozšíření}

Parasim je schopen načíst rozšíření, která jsou v době vytvoření manažera na \texttt{Java class path}.
Všechna zatím použitá rozšíření byla přibalena do souboru JAR aplikace pomocí sestavovacího
nástroje Maven, a proto jsou k dispozici bez dalšího nastavování. Rozšíření musí obsahovat
následující části:

\begin{itemize}
	\item	alespoń jednu třidu, která implementuje rozhraní \href{https://github.com/sybila/parasim/blob/master/core/src/main/java/org/sybila/parasim/core/spi/LoadableExtension.java}{LoadableExtension},
	\item	soubor \texttt{META-INF/services/org.sybila.parasim.core.spi.\\LoadableExtension} obsahující plné názvy všech tříd z daného roz\-ší\-ření implementující \href{https://github.com/sybila/parasim/blob/master/core/src/main/java/org/sybila/parasim/core/spi/LoadableExtension.java}{LoadableExtension}, jeden název na jednom řád\-ku. 
\end{itemize}

Rozhraní \href{https://github.com/sybila/parasim/blob/master/core/src/main/java/org/sybila/parasim/core/spi/LoadableExtension.java}{LoadableExtension}
obsahuje jedinou metodu, ve které je pře\-dán objekt pro registraci tříd rozšíření. Je možné
registrovat služby ne\-zá\-vi\-slé na kontextu a tzv. pozorovatele, což jsou třídy poskytující
služby a naslouchající událostem. Podrobnější příklad toho, jak rozšíření může vypadat,
se nachází v příloze \ref{appendix:extension}. Tato sekce obsahuje pouze vysvětlení
nej\-dů\-le\-ži\-těj\-ších konceptů.

Již zmínění pozorovatelé jsou schopni pomocí metod označených anotací \href{https://github.com/sybila/parasim/blob/master/core/src/main/java/org/sybila/parasim/core/annotation/Provide.java}{\texttt{Provide}}
poskytovat instance služeb. V deklaraci metody se mohou na\-chá\-zet parametry,
které je manažer jádra Parasimu schopen vyhodnotit a injektovat. Tyto parametry
lze označovat kvalifikátory. V případě, že není žádný kvalifikátor k dispozici,
je pro vyhodonocení hodnoty parametru použit kvalifikátor \href{https://github.com/sybila/parasim/blob/master/core/src/main/java/org/sybila/parasim/core/annotation/Default.java}{\texttt{Default}}.

\begin{lstlisting}[label={code:provide:required}, caption={První metoda poskytující službu \texttt{Functionality}}]
/**
 * selze, pokud neni v aktualnim kontextu k dispozici 
 * retezec pro dosazeni za parametr metody
 */
@Provide
public Functionality provideFunctionality(
		String required) {

	return new FunctionalityImpl(required);
}
\end{lstlisting}

V případě, že je manažer požádán, aby poskytl instanci služby, metoda poskytující danou službu je zavolána,
poskytnutý objekt propagován jako událost do všech dostupných rozšíření, a poté uložen pro případ,
že by byla služba požadována znovu. Výjimku tvoří poskytující metody, pro jejichž
návratový typ nelze vytvořit proxy\footnote{Typickým příkladem typů, pro které nelze vytvořit proxy, jsou finální třídy.}.
Takové poskytující metody jsou zavolány již během načítání rozšíření. Pokud v čase volání
poskytující metody nelze najít hodnoty pro všechny její parametry, dojde k vyhození výjimky a
pravděpodobně k pádu aplikace.

\begin{lstlisting}[label={code:provide:optional}, caption={Druhá metoda poskytující službu \texttt{Functionality}}]
/**
 * pokud neni v aktualnim kontextu k dispozici 
 * retezec pro dosazeni za parametr metody,
 * bude pouzita hodnota null
 */
@Provide
public Functionality provideFunctionality(
		@Inject(required=false) String optional) {

	return new FunctionalityImpl(optional);
}
\end{lstlisting}

Jestliže chce autor rozšíření záviset na jiných službách pouze volně, lze použít 
u parametrů poskytujících metod anotace \href{https://github.com/sybila/parasim/blob/master/core/src/main/java/org/sybila/parasim/core/annotation/Inject.java}{\texttt{Inject}} způsobem u\-ká\-za\-ným ve zdrojovém
kódu \ref{code:provide:optional}.

Druhým typem metod v pozorovatelských třídách jsou metody na\-slou\-cha\-jí\-cí událostem.
Aby bylo možné tyto metody rozlišit, je první parametr těchto metod je označen anotací \href{https://github.com/sybila/parasim/blob/master/core/src/main/java/org/sybila/parasim/core/annotation/Observes.java}{\texttt{Observes}}
a typ tohoto parametru určuje typ naslouchané události. Pro další parametry těchto metod platí
stejná pravidla jako pro parametry poskytujících metod. Pro vytvoření vlastních událostí
je k dispozici služba \href{https://github.com/sybila/parasim/blob/master/core/src/main/java/org/sybila/parasim/core/api/EventDispatcher.java}{\texttt{EventDispatcher}}.

\subsection{Konfigurace}

Jádro Parasimu nabízí jednoduchý způsob konfigurace jednotný pro všech\-na rozšíření
a tím vybízí autory rozšíření, aby ve svých rozšířeních umožnili konfigurací změnit
co nejvíce věcí. Zároveň je však kladen důraz na to, aby rozšíření bylo funkční 
samo o sobě bez toho, aby jej uživatel musel konfigurovat.

Pro autory rozšíření je k dispozici služba \href{https://github.com/sybila/parasim/blob/master/core/src/main/java/org/sybila/parasim/core/api/configuration/ParasimDescriptor.java}{\texttt{ParasimDescriptor}},
která je schopná na základě názvu rozšíření vrátit hodnoty konfiguračních pro\-měn\-ných
ve formě řetězců, dále služba \href{https://github.com/sybila/parasim/blob/master/core/src/main/java/org/sybila/parasim/core/api/configuration/ExtensionDescriptorMapper.java}{\texttt{ExtensionDescriptorMapper}} schopná namapovat hodnoty konfiguračních pro\-měn\-ných
namapovat do atributů u objektu v Javě. Mapování umí automaticky převést řetězce
do nejpoužívanějších datových typů.

Autor rozšíření tedy vytvoří konfigurační třídu s atributy, jejíchž názvy se shodují
s požadovanými názvy konfiguračních proměnných Výchozí hodnoty těchto atributů jsou
zároveň výchozími hodnotami pro konfiguraci rozšíření. Ukázka toho, jak může vypadat
zpřístupnění konfigurace v rozšíření je k dispozici v~příloze \ref{appendix:configuration}.

Při užívání aplikace lze konfiguraci lze změnit dvěma způsoby:

\begin{itemize}
	\item	Pomocí systémové proměnné \texttt{parasim.config.file} v Javě je mož\-né nastavit cestu k XML souboru.
			Výchozí cesta k tomuto souboru je nastavena na \uv{parasim.xml}. Tento soubor
			obsahuje pojmenované sekce a v těchto sekcích nastavení pro jednotlivé konfigurační
			pro\-měn\-né. Názvy proměnných se shodují s názvy atributů konfiguračních objektů.

	\item	Pro každou konfigurační proměnnou lze přepsat její hodnotu pomocí systémové
			proměnné v Javě, jejíž název je \texttt{parasim.<název roz\-ší\-ření>.<název konfugurační proměnné>}.
			Název rozšíření i konfigurační promměné se zde uvádí v tečkové notaci, například pro atribut \texttt{timeUnit}
			a rozšíření \texttt{example} se bude systémová proměnná nazývat \texttt{parasim.example.time.unit}.
\end{itemize}

Pokud je nutné nějakou část konfigurace zpřístupnit
změnám nejen při startu aplikace, ale i při jejím běhu skrze systémové proměnné, je potřeba mít na paměti
okamžik, ve kterém se vytváří konfigurační objekt. Jakmile je totiž konfigurační objekt vytvořen,
již nelze hodnoty konfigurace jemu náležící změnit. Po změně systémové proměnné,
je možné si znovunačtení konfiguračního objektu vynutit zničením příslušnoho kontextu
a vy\-tvo\-ře\-ním nového. Na to však není vhodný aplikační kontext, protože jeho
zničení prakticky znamená vypnutí aplikace.

\subsection{Obohacování}

Aby nebylo nutné si na všech místech předávat instanci manežera, případně instance všech
potřebných služeb, nabízí Parasim rozšiřitelný mechanismus obohacování objektů.
To je umožněno pomocí služby \href{https://github.com/sybila/parasim/blob/master/core/src/main/java/org/sybila/parasim/core/api/enrichment/Enrichment.java}{\texttt{Enrichment}}.
Tato služba spouští objety na kontextu nezávislých služeb \href{https://github.com/sybila/parasim/blob/master/core/src/main/java/org/sybila/parasim/core/spi/enrichment/Enricher.java}{\texttt{Enricher}}
na dané instanci, které ji dokáží různým způsobem vylepšit. 

Jádro Parasimu obsahuje dvě implementace rozhraní \href{https://github.com/sybila/parasim/blob/master/core/src/main/java/org/sybila/parasim/core/spi/enrichment/Enricher.java}{\texttt{Enricher}},
které umožní zpřístupnit poskytující metody a atributy podobně jako u rozšíření 
a které injektují služby do atributů. Za tímto účelem se používají již zmíněné anotace \href{https://github.com/sybila/parasim/blob/master/core/src/main/java/org/sybila/parasim/core/annotation/Provide.java}{\texttt{Provide}} a \href{https://github.com/sybila/parasim/blob/master/core/src/main/java/org/sybila/parasim/core/annotation/Inject.java}{\texttt{Inject}}.
Tyto anotace lze použít ve dvou nastaveních, v jednom nastavení bude při obohoacování
vyhozena výjimka, pokud poskytovaný případně injektovaný objekt není k dispozici.
Pokud je anotace použita s přiřazením \texttt{required=false}, výjimka se nevyhodí.

\subsection{Vzdálený přístup}

Další části práce ukážou, jak je možné Parasim použít k distribovanému počítání.
To je umožněno pomocí rozšíření pro vzdálený přístup, které u\-mož\-ňu\-je získat
některé služby nacházející se v aplikačním kontextu nějaké vzdáleného stroje.
Na tomto stroji je nejprve nutné tuto funkcionalitu aktivovat skrze rozhraní \href{https://github.com/sybila/parasim/blob/master/core/src/main/java/org/sybila/parasim/core/api/remote/Loader.java}{\texttt{Loader.java}},
jak je ukázáno ve zdrojovém kódu \ref{code:remote}. Ukázaný kód nastartuje server
pro práci s \textit{Remote Method Invocation}~\cite{grosso2001} a na tento server vystaví \href{https://github.com/sybila/parasim/blob/master/core/src/main/java/org/sybila/parasim/core/api/remote/Loader.java}{\texttt{Loader.java}}.

\begin{lstlisting}[label={code:remote}, caption={Spuštění serveru}]
manager.resolve(Loader.class, Default.class)
	   .load(Loader.class, Default.class);
\end{lstlisting}
Ostatní stroje jsou pak schopny vynutit si vystavení služeb z aplikačního kontextu
tohoto stroje na tento server. Aby bylo možné službu vystavit, je nutné, aby implementovala
rozhraní \texttt{java.rmi.Remote}. Jakmile je server na vzdáleném stroji aktivován,
je možné s ním komunikovat podobně jako ve zdrojovém kódu \ref{code:host:control}.

\begin{lstlisting}[label={code:host:control}, caption={Přístup ke vzdálenému serveru}]
HostControl control = new HostControlImpl(
		new URI("localhost"))
if (!control.isRunning(true)) {
	throw new IllegalStateException();
}
RemoteServis servis = control
		.lookup(RemoteServis.class, Default.class);
\end{lstlisting}

Jakákoliv interakce s takto získanými službami vyvolá síťovou komunikaci a veškerá logika
služby se vyhodnocuje na straně vzdáleného stroje.

\section{Výpočetní model}

Parasim obsahuje rozšíření pro snadnější provádění jistého výpočtu vý\-poč\-tu.
Základní jednotku výpočtu zde představuje instance. Během průběhu po\-čí\-tá\-ní lze
tuto instance rozdělit na více dalších a ty počítat nezávisle na sobě. Jednotlivé instance
se mohou dále dělit a vrací mezivýsledky, které je možné slučovat pomocí asociativní
a komutativní operace. Jak přesně se výpočetní instance dělí a jak jsou mezivýsledky
slučovány, určuje ten, kdo implementuje algoritmus.

Důležitým aspektem však je, že se vývojář implementující algoritmus nemusí starat
o způsob, jakým konkrétně budou výpočetní instance provedeny. Parasim tím nabízí
jednotné rozhraní pro výpočty ve sdílené a~dístribuované paměti.

\subsection{Reprezentace výsledku}

Třída reprezentující výsledek pro daný výpočet musí implementovat rozhraní \href{https://github.com/sybila/parasim/blob/master/model/core/src/main/java/org/sybila/parasim/model/Mergeable.java}{\texttt{Mergeable}}. Toto rozhraní si vynucuje krom uchování dat také definci komutativní
a asociativní operaci pro slučování mezivýsledků. Zároveň je nezbytné, aby třída
byla schopna serializace. Serializace je nezbytná pro výpočet v distribuované paměti,
kde se data po skončení mezivýpočtu po\-sí\-la\-jí mezi počítači po síti.

Z formálního hlediska již není kladen na datový typ výsledku žádný požadavek, nicméně
je třeba mít na paměti, že ...

\subsection{Reprezentace výpočtu}

\subsection{Výpočet ve sdílené paměti}

\subsection{Výpočet v distribované paměti}

\subsection{Možná nastavení výpočtu}


\begin{figure}[h!]
\label{figure:computation:shared:memory}
\begin{center}
\resizebox{0.9\textwidth}{!}{
\begin{tikzpicture}  	[node distance=1.8cm,start chain=going below]
\tikzset{>=stealth',
	event/.style={
    	rectangle, 
    	rounded corners, 
    	fill=green!20,
    	draw=black, very thick,
    	text width=9em, 
    	minimum height=3em, 
    	text centered},
	class/.style={
    	rectangle, 
    	rounded corners, 
    	fill=black!10,
    	draw=black, very thick,
    	text width=10em, 
    	minimum height=3em, 
    	text centered},
	package/.style={
		rectangle,
		draw=black!50, dashed,
		rounded corners,
		inner sep=0.3cm},
 	scope/.style={decorate},
	code/.style={
		rectangle,
		draw=black!50, dashed,
		rounded corners,
    	minimum height=3em, 
    	text centered}
}
	\node[class] (computation) {Computation comp\\výpočet};
	\node[code, below of=computation] (compute) {ComputationContainer.compute(comp)};
	\node[code, below of=compute] (execute) {Executor.submit(comp)};
	\node[event, below of=execute] (before-computation) {BEFORE\\kontext výpočtu};
	\node[event, below of=before-computation] (before-computation-instance-1) {BEFORE\\kontext\\instance výpočtu};
	\node[class, below of=before-computation-instance-1] (computation-copy-1) {kopie\\instance výpočtu};
	\node[code, below of=computation-copy-1] (computation-enrichment-1) {obohacení instance výpočtu};
	\node[code, below of=computation-enrichment-1] (thread-pool-executor-execute-1) {spuštění instance výpočtu};
	\node[class, below of=thread-pool-executor-execute-1] (result-partial-1) {mezivýsledek};
	\node[code, below of=result-partial-1] (computation-instance-destroy-1) {zničení instance výpočtu};
	\node[event, below of=computation-instance-destroy-1] (after-computation-instance-1) {AFTER\\kontext\\instance výpočtu};
	\node[event, below of=after-computation-instance-1] (after-computation) {AFTER\\kontext výpočtu};
	\node[class, below of=after-computation] (result) {výsledek};

	\node[event, left of=before-computation-instance-1, node distance=5cm] (before-computation-instance-2) {BEFORE\\kontext\\instance výpočtu};
	\node[class, below of=before-computation-instance-2] (computation-copy-2) {kopie\\instance výpočtu};
	\node[code, below of=computation-copy-2] (computation-enrichment-2) {obohacení instance výpočtu};
	\node[code, below of=computation-enrichment-2] (thread-pool-executor-execute-2) {spuštění instance výpočtu};
	\node[class, below of=thread-pool-executor-execute-2] (result-partial-2) {mezivýsledek};
	\node[code, below of=result-partial-2] (computation-instance-destroy-2) {zničení instance výpočtu};
	\node[event, below of=computation-instance-destroy-2] (after-computation-instance-2) {AFTER\\kontext\\instance výpočtu};

	\node[event, right of=before-computation-instance-1, node distance=5cm] (before-computation-instance-3) {BEFORE\\kontext\\instance výpočtu};
	\node[class, below of=before-computation-instance-3] (computation-copy-3) {kopie\\instance výpočtu};
	\node[code, below of=computation-copy-3] (computation-enrichment-3) {obohacení instance výpočtu};
	\node[code, below of=computation-enrichment-3] (thread-pool-executor-execute-3) {spuštění instance výpočtu};
	\node[class, below of=thread-pool-executor-execute-3] (result-partial-3) {mezivýsledek};
	\node[code, below of=result-partial-3] (computation-instance-destroy-3) {zničení instance výpočtu};
	\node[event, below of=computation-instance-destroy-3] (after-computation-instance-3) {AFTER\\kontext\\instance výpočtu};


	\begin{scope}[->, thick]
		\draw (computation) -> (compute);
		\draw (compute) -> (execute);
		\draw (execute) -> (before-computation);
		\draw (after-computation) -> (result);

		\draw (before-computation) -> (before-computation-instance-1);
		\draw (before-computation) -> (before-computation-instance-2);
		\draw (before-computation) -> (before-computation-instance-3);

		\draw (before-computation-instance-1) -> (computation-copy-1);
		\draw (before-computation-instance-2) -> (computation-copy-2);
		\draw (before-computation-instance-3) -> (computation-copy-3);

		\draw (computation-copy-1) -> (computation-enrichment-1);
		\draw (computation-copy-2) -> (computation-enrichment-2);
		\draw (computation-copy-3) -> (computation-enrichment-3);

		\draw (computation-enrichment-1) -> (thread-pool-executor-execute-1);
		\draw (computation-enrichment-2) -> (thread-pool-executor-execute-2);
		\draw (computation-enrichment-3) -> (thread-pool-executor-execute-3);

		\draw (thread-pool-executor-execute-1) -> (result-partial-1);
		\draw (thread-pool-executor-execute-2) -> (result-partial-2);
		\draw (thread-pool-executor-execute-3) -> (result-partial-3);

		\draw (result-partial-1) -> (computation-instance-destroy-1);
		\draw (result-partial-2) -> (computation-instance-destroy-2);
		\draw (result-partial-3) -> (computation-instance-destroy-3);

		\draw (computation-instance-destroy-1) -> (after-computation-instance-1);
		\draw (computation-instance-destroy-2) -> (after-computation-instance-2);
		\draw (computation-instance-destroy-3) -> (after-computation-instance-3);

		\draw (after-computation-instance-1) -> (after-computation);
		\draw (after-computation-instance-2) -> (after-computation);
		\draw (after-computation-instance-3) -> (after-computation);
	\end{scope}
\end{tikzpicture}}
\end{center}
\caption{Schéma průběhu výpočtu ve sdílené paměti. Zelené obdelníky představují události,
šedými obdelníkymi objekty a čerchovaně ohraničené jsou části Java kódu.}
\end{figure}

\begin{figure}[h!]
\label{figure:computation:events}
\begin{center}
\resizebox{0.9\textwidth}{!}{
\begin{tikzpicture}  	[node distance=1.8cm,start chain=going below]
\tikzset{>=stealth',
	event/.style={
    	rectangle, 
    	rounded corners, 
    	fill=green!20,
    	draw=black, very thick,
    	text width=9em, 
    	minimum height=3em, 
    	text centered},
	class/.style={
    	rectangle, 
    	rounded corners, 
    	fill=black!10,
    	draw=black, very thick,
    	text width=8em, 
    	minimum height=3em, 
    	text centered},
	package/.style={
		rectangle,
		draw=black!50, dashed,
		rounded corners,
		inner sep=0.3cm},
 	scope/.style={decorate},
	code/.style={
		rectangle,
		draw=black!50, dashed,
		rounded corners,
    	minimum height=3em, 
    	text centered}
}
	\node[class] (computation-instance) {instance výpočtu};
	\node[event, right of=computation-instance, node distance=5cm] (mucker) {Mucker};
	\node[event, above of=mucker, node distance=5cm] (computing) {Future};

	\begin{scope}[->, thick]
		\path (computation-instance) edge node[below] {emitted} (mucker);
	\end{scope}
\end{tikzpicture}}
\end{center}
\caption{jsdhkjfshd fskjdhf skjd hfsldfkj }
\end{figure}

\section{Dostupná rozšíření}
